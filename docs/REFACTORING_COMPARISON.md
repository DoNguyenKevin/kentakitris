# üîÑ So s√°nh Before/After Refactoring

## üìä T·ªïng quan

| Metric | Before | After | Thay ƒë·ªïi |
|--------|--------|-------|----------|
| **T·ªïng s·ªë file** | 1 | 4 | +3 files |
| **Game.ts** | 1206 d√≤ng | 673 d√≤ng | -533 d√≤ng (-44.2%) |
| **GameConstants.ts** | - | 121 d√≤ng | +121 d√≤ng |
| **EnergyBlockManager.ts** | - | 474 d√≤ng | +474 d√≤ng |
| **GameRenderer.ts** | - | 202 d√≤ng | +202 d√≤ng |
| **T·ªïng d√≤ng code** | 1206 | 1470 | +264 d√≤ng |

> ‚ùì **C√¢u h·ªèi:** T·∫°i sao t·ªïng d√≤ng code l·∫°i TƒÇNG?
> 
> üí° **Tr·∫£ l·ªùi:** V√¨ ta th√™m nhi·ªÅu comment gi√°o d·ª•c, documentation v√† structure r√µ r√†ng h∆°n. ƒêi·ªÅu n√†y l√† T·ªêT v√¨ code d·ªÖ hi·ªÉu h∆°n!

## üìÅ C·∫•u tr√∫c file

### Before (1 file)
```
src/game/scenes/
‚îî‚îÄ‚îÄ Game.ts (1206 d√≤ng)
    ‚îú‚îÄ‚îÄ Constants (SHAPES, COLORS, etc.)
    ‚îú‚îÄ‚îÄ Interfaces (Piece, EnergyBlock)
    ‚îú‚îÄ‚îÄ Game class
    ‚îÇ   ‚îú‚îÄ‚îÄ Properties
    ‚îÇ   ‚îú‚îÄ‚îÄ create()
    ‚îÇ   ‚îú‚îÄ‚îÄ update()
    ‚îÇ   ‚îú‚îÄ‚îÄ render() - 100+ d√≤ng
    ‚îÇ   ‚îú‚îÄ‚îÄ Energy blocks methods (10 methods)
    ‚îÇ   ‚îú‚îÄ‚îÄ Game logic methods
    ‚îÇ   ‚îî‚îÄ‚îÄ ...
```

### After (4 files)
```
src/game/
‚îú‚îÄ‚îÄ constants/
‚îÇ   ‚îî‚îÄ‚îÄ GameConstants.ts (121 d√≤ng)
‚îÇ       ‚îú‚îÄ‚îÄ BOARD_WIDTH, BOARD_HEIGHT, BLOCK_SIZE
‚îÇ       ‚îú‚îÄ‚îÄ BOARD_X, BOARD_Y
‚îÇ       ‚îú‚îÄ‚îÄ COLORS, SHAPES
‚îÇ       ‚îú‚îÄ‚îÄ FROZEN_TEXT_BLINK_CYCLE
‚îÇ       ‚îú‚îÄ‚îÄ interface Piece
‚îÇ       ‚îî‚îÄ‚îÄ interface EnergyBlock
‚îÇ
‚îú‚îÄ‚îÄ managers/
‚îÇ   ‚îî‚îÄ‚îÄ EnergyBlockManager.ts (474 d√≤ng)
‚îÇ       ‚îú‚îÄ‚îÄ EnergyBlockManager class
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ trySpawnEnergyBlock()
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ update()
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ render()
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ initMouseTracking()
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ checkMouseProximity()
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ explodeEnergyBlock()
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ freezeMouse()
‚îÇ
‚îú‚îÄ‚îÄ helpers/
‚îÇ   ‚îî‚îÄ‚îÄ GameRenderer.ts (202 d√≤ng)
‚îÇ       ‚îú‚îÄ‚îÄ GameRenderer class
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ render()
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ renderBoard()
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ renderCurrentPiece()
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ renderNextPiece()
‚îÇ
‚îî‚îÄ‚îÄ scenes/
    ‚îî‚îÄ‚îÄ Game.ts (673 d√≤ng)
        ‚îú‚îÄ‚îÄ Game class
        ‚îÇ   ‚îú‚îÄ‚îÄ Properties (s·ª≠ d·ª•ng managers)
        ‚îÇ   ‚îú‚îÄ‚îÄ create()
        ‚îÇ   ‚îú‚îÄ‚îÄ update() - 15 d√≤ng
        ‚îÇ   ‚îú‚îÄ‚îÄ render() - 5 d√≤ng
        ‚îÇ   ‚îî‚îÄ‚îÄ Game logic methods
```

## üîç So s√°nh code c·ª• th·ªÉ

### 1. Update Method

#### Before (Game.ts - d√†i v√† ph·ª©c t·∫°p)
```typescript
update() {
    if (this.gameOver) return;

    // X·ª≠ l√Ω input
    if (Phaser.Input.Keyboard.JustDown(this.cursors.left!)) {
        this.movePiece(-1, 0);
    }
    if (Phaser.Input.Keyboard.JustDown(this.cursors.right!)) {
        this.movePiece(1, 0);
    }
    if (Phaser.Input.Keyboard.JustDown(this.cursors.down!)) {
        this.movePiece(0, 1);
    }

    // Update energy blocks - 50+ d√≤ng logic ·ªü ƒë√¢y
    const currentTime = Date.now();
    for (let i = this.energyBlocks.length - 1; i >= 0; i--) {
        const block = this.energyBlocks[i];
        if (currentTime - block.lastDropTime >= block.dropSpeed) {
            block.y++;
            block.lastDropTime = currentTime;
            if (block.y >= BOARD_HEIGHT) {
                this.energyBlocks.splice(i, 1);
                this.endGame();
                return;
            }
            if (this.board[block.y] && this.board[block.y][block.x] !== 0) {
                this.energyBlocks.splice(i, 1);
                this.endGame();
                return;
            }
        }
    }

    // Render - 100+ d√≤ng v·∫Ω ·ªü ƒë√¢y
    this.render();
}
```

#### After (Game.ts - ng·∫Øn g·ªçn v√† r√µ r√†ng)
```typescript
update() {
    if (this.gameOver) return;

    // ‚å®Ô∏è X·ª≠ l√Ω input t·ª´ b√†n ph√≠m
    if (Phaser.Input.Keyboard.JustDown(this.cursors.left!)) {
        this.movePiece(-1, 0);
    }
    if (Phaser.Input.Keyboard.JustDown(this.cursors.right!)) {
        this.movePiece(1, 0);
    }
    if (Phaser.Input.Keyboard.JustDown(this.cursors.down!)) {
        this.movePiece(0, 1);
    }

    // ‚ö° C·∫≠p nh·∫≠t energy blocks (1 d√≤ng!)
    this.energyBlockManager.update();

    // üé® V·∫Ω l·∫°i m√†n h√¨nh
    this.render();
}
```

**‚úÖ C·∫£i thi·ªán:**
- Ng·∫Øn h∆°n: 25+ d√≤ng ‚Üí 15 d√≤ng
- R√µ r√†ng h∆°n: Logic energy blocks ƒë∆∞·ª£c ·∫©n trong manager
- D·ªÖ ƒë·ªçc h∆°n: Kh√¥ng b·ªã ph√¢n t√¢m b·ªüi chi ti·∫øt implementation

### 2. Render Method

#### Before (Game.ts - 100+ d√≤ng)
```typescript
render() {
    const boardX = 200;
    const boardY = 50;

    // Clear graphics
    this.boardGraphics.clear();
    this.pieceGraphics.clear();
    this.nextPieceGraphics.clear();
    this.energyBlockGraphics.clear();

    // Draw board border (10+ d√≤ng)
    this.boardGraphics.lineStyle(4, 0x888888);
    this.boardGraphics.strokeRect(
        boardX - 2, boardY - 2,
        BOARD_WIDTH * BLOCK_SIZE + 4,
        BOARD_HEIGHT * BLOCK_SIZE + 4
    );

    // Draw board grid (20+ d√≤ng)
    this.boardGraphics.lineStyle(1, 0x333333);
    for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
            const px = boardX + x * BLOCK_SIZE;
            const py = boardY + y * BLOCK_SIZE;
            this.boardGraphics.strokeRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
            
            if (this.board[y][x] !== 0) {
                this.boardGraphics.fillStyle(COLORS[this.board[y][x]], 1);
                this.boardGraphics.fillRect(px + 1, py + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
            }
        }
    }

    // Draw energy blocks (40+ d√≤ng)
    for (const block of this.energyBlocks) {
        const px = boardX + block.x * BLOCK_SIZE;
        const py = boardY + block.y * BLOCK_SIZE;
        // ... v·∫Ω energy block v·ªõi hi·ªáu ·ª©ng
    }

    // Draw current piece (20+ d√≤ng)
    if (this.currentPiece) {
        for (let r = 0; r < this.currentPiece.shape.length; r++) {
            for (let c = 0; c < this.currentPiece.shape[r].length; c++) {
                if (this.currentPiece.shape[r][c] !== 0) {
                    const px = boardX + (this.currentPiece.x + c) * BLOCK_SIZE;
                    const py = boardY + (this.currentPiece.y + r) * BLOCK_SIZE;
                    // ... v·∫Ω √¥
                }
            }
        }
    }

    // Draw next piece (15+ d√≤ng)
    // ...
}
```

#### After (Game.ts - 5 d√≤ng)
```typescript
render() {
    // üé® V·∫Ω board, current piece v√† next piece
    this.gameRenderer.render(this.board, this.currentPiece, this.nextPiece);
    
    // ‚ö° V·∫Ω energy blocks
    this.energyBlockManager.render();
}
```

**‚úÖ C·∫£i thi·ªán:**
- C·ª±c ng·∫Øn: 100+ d√≤ng ‚Üí 5 d√≤ng
- Tr√°ch nhi·ªám r√µ r√†ng: GameRenderer lo vi·ªác v·∫Ω
- D·ªÖ thay ƒë·ªïi: Mu·ªën ƒë·ªïi c√°ch v·∫Ω? Ch·ªâ s·ª≠a GameRenderer

### 3. Constants Usage

#### Before (Game.ts - magic numbers kh·∫Øp n∆°i)
```typescript
class Game {
    createUI() {
        const boardX = 200;  // ‚ùå Magic number
        const boardY = 50;   // ‚ùå Magic number
        
        this.add.text(boardX + BOARD_WIDTH * BLOCK_SIZE / 2, 20, 'KENTAKITRIS', {
            // ...
        });
        
        const scoreX = boardX + BOARD_WIDTH * BLOCK_SIZE + 50;
        const scoreY = boardY + 20;
        // ...
    }
}
```

#### After (S·ª≠ d·ª•ng constants)
```typescript
// GameConstants.ts
export const BOARD_X = 200;
export const BOARD_Y = 50;

// Game.ts
import { BOARD_X, BOARD_Y, BOARD_WIDTH, BLOCK_SIZE } from '../constants/GameConstants';

class Game {
    createUI() {
        this.add.text(BOARD_X + BOARD_WIDTH * BLOCK_SIZE / 2, 20, 'KENTAKITRIS', {
            // ...
        });
        
        const scoreX = BOARD_X + BOARD_WIDTH * BLOCK_SIZE + 50;
        const scoreY = BOARD_Y + 20;
        // ...
    }
}
```

**‚úÖ C·∫£i thi·ªán:**
- Kh√¥ng c√≤n magic numbers
- D·ªÖ thay ƒë·ªïi: S·ª≠a 1 ch·ªó ‚Üí thay ƒë·ªïi to√†n b·ªô
- R√µ nghƒ©a: BOARD_X r√µ h∆°n 200

### 4. Energy Blocks Management

#### Before (Game.ts - t·∫•t c·∫£ trong 1 class)
```typescript
class Game extends Scene {
    energyBlocks: EnergyBlock[];
    isMouseFrozen: boolean;
    frozenText: Text | null;
    
    shouldSpawnEnergyBlock() { /* 15 d√≤ng */ }
    createEnergyBlock() { /* 20 d√≤ng */ }
    trySpawnEnergyBlock() { /* 10 d√≤ng */ }
    updateEnergyBlocks() { /* 50 d√≤ng */ }
    initMouseTracking() { /* 20 d√≤ng */ }
    checkMouseProximity() { /* 30 d√≤ng */ }
    explodeEnergyBlock() { /* 50 d√≤ng */ }
    freezeMouse() { /* 30 d√≤ng */ }
    
    // + t·∫•t c·∫£ c√°c ph∆∞∆°ng th·ª©c game kh√°c
}
```

#### After (T√°ch th√†nh EnergyBlockManager)
```typescript
// EnergyBlockManager.ts - T·∫≠p trung v√†o energy blocks
export class EnergyBlockManager {
    private energyBlocks: EnergyBlock[];
    private isMouseFrozen: boolean;
    private frozenText: Text | null;
    
    shouldSpawnEnergyBlock() { /* ... */ }
    createEnergyBlock() { /* ... */ }
    trySpawnEnergyBlock() { /* ... */ }
    update() { /* ... */ }
    render() { /* ... */ }
    // ... c√°c ph∆∞∆°ng th·ª©c kh√°c
}

// Game.ts - Ch·ªâ s·ª≠ d·ª•ng manager
class Game extends Scene {
    energyBlockManager: EnergyBlockManager;
    
    create() {
        this.energyBlockManager = new EnergyBlockManager(
            this, this.difficulty, BOARD_X, BOARD_Y,
            this.board, () => this.endGame(), () => this.gameOver
        );
        this.energyBlockManager.init();
    }
    
    update() {
        this.energyBlockManager.update();
    }
}
```

**‚úÖ C·∫£i thi·ªán:**
- T√°ch bi·ªát tr√°ch nhi·ªám
- D·ªÖ test: C√≥ th·ªÉ test EnergyBlockManager ri√™ng
- C√≥ th·ªÉ t√°i s·ª≠ d·ª•ng: D√πng ƒë∆∞·ª£c trong scene kh√°c
- Game.ts ng·∫Øn g·ªçn h∆°n

## üéì B√†i h·ªçc cho h·ªçc sinh

### 1. **Principle of Least Surprise**
Code n√™n l√†m ƒë√∫ng nh∆∞ t√™n g·ªçi:
- `update()` ch·ªâ n√™n ƒëi·ªÅu ph·ªëi, kh√¥ng n√™n c√≥ 100 d√≤ng logic
- `render()` ch·ªâ n√™n v·∫Ω, ·ªßy th√°c cho renderer

### 2. **Encapsulation**
·∫®n chi ti·∫øt implementation:
- Game kh√¥ng c·∫ßn bi·∫øt energy block v·∫Ω nh∆∞ th·∫ø n√†o
- Ch·ªâ c·∫ßn g·ªçi `energyBlockManager.render()`

### 3. **Single File = Single Purpose**
M·ªói file n√™n c√≥ 1 m·ª•c ƒë√≠ch duy nh·∫•t:
- GameConstants.ts = Constants
- EnergyBlockManager.ts = Qu·∫£n l√Ω energy blocks
- GameRenderer.ts = V·∫Ω game
- Game.ts = ƒêi·ªÅu ph·ªëi ch√≠nh

### 4. **Dependency Injection**
Truy·ªÅn dependencies qua constructor:
```typescript
// ‚úÖ T·ªët - Linh ho·∫°t
new EnergyBlockManager(scene, difficulty, x, y, board, onGameOver, isGameOver)

// ‚ùå Kh√¥ng t·ªët - C·ª©ng nh·∫Øc
class EnergyBlockManager {
    constructor() {
        this.scene = Game.instance; // Ph·ª• thu·ªôc global
    }
}
```

## üìà Metrics

### Code Complexity (gi·∫£m)
- **Before:** Cyclomatic Complexity c·ªßa Game.ts: ~50
- **After:** 
  - Game.ts: ~20
  - EnergyBlockManager.ts: ~15
  - GameRenderer.ts: ~10

### Maintainability (tƒÉng)
- **Before:** 1 developer ph·∫£i hi·ªÉu 1206 d√≤ng ƒë·ªÉ s·ª≠a bug
- **After:** Developer ch·ªâ c·∫ßn hi·ªÉu file li√™n quan (200-500 d√≤ng)

### Testability (tƒÉng)
- **Before:** Kh√≥ test ri√™ng energy blocks ho·∫∑c rendering
- **After:** D·ªÖ d√†ng test t·ª´ng module ƒë·ªôc l·∫≠p

### Reusability (tƒÉng)
- **Before:** Kh√¥ng th·ªÉ t√°i s·ª≠ d·ª•ng
- **After:** GameRenderer, EnergyBlockManager c√≥ th·ªÉ d√πng ·ªü scene kh√°c

## üöÄ K·∫øt lu·∫≠n

Refactoring n√†y ƒë√£:
- ‚úÖ Gi·∫£m 44% ƒë·ªô d√†i Game.ts
- ‚úÖ T√°ch th√†nh 4 file c√≥ tr√°ch nhi·ªám r√µ r√†ng
- ‚úÖ TƒÉng kh·∫£ nƒÉng ƒë·ªçc code
- ‚úÖ TƒÉng kh·∫£ nƒÉng maintain
- ‚úÖ TƒÉng kh·∫£ nƒÉng test
- ‚úÖ TƒÉng kh·∫£ nƒÉng t√°i s·ª≠ d·ª•ng
- ‚úÖ Lo·∫°i b·ªè magic numbers
- ‚úÖ Kh√¥ng ph√° v·ª° ch·ª©c nƒÉng
- ‚úÖ Build th√†nh c√¥ng
- ‚úÖ Kh√¥ng c√≥ l·ªói b·∫£o m·∫≠t

**"Code is read much more often than it is written"** - Guido van Rossum

V√¨ v·∫≠y, vi·ªác refactor ƒë·ªÉ code d·ªÖ ƒë·ªçc l√† r·∫•t quan tr·ªçng! üìö‚ú®
