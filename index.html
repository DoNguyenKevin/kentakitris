<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Tetris</title>
    <!-- Load Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load custom CSS -->
    <link rel="stylesheet" href="index.css">
    <!-- Load Firebase SDKs - Realtime Database -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getDatabase, ref, set, query, orderByChild, limitToLast, onValue } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB20BwcVcwBBLQc8p-hPH6v2dd1Ag8uvgk",
            authDomain: "kentakitris.firebaseapp.com",
            databaseURL: "https://kentakitris-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "kentakitris",
            storageBucket: "kentakitris.firebasestorage.app",
            messagingSenderId: "813070706725",
            appId: "1:813070706725:web:50bdddc7bdfa897ab877cc",
            measurementId: "G-DMJSY5GMQS"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);
        
        // Global variables
        let userId = null;
        let playerName = localStorage.getItem('playerName') || null;

        // Attach to window for game logic access
        window.db = db;
        window.auth = auth;

        // Authentication
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                window.userId = userId;
                
                // Display user info
                const shortId = userId.substring(0, 8);
                const displayName = playerName || shortId;
                document.getElementById('user-id-display').textContent = `Player: ${displayName}`;
                
                // Start listening to leaderboard once authenticated
                if (window.loadLeaderboard) {
                    window.loadLeaderboard();
                }
            } else {
                // Sign in anonymously
                try {
                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("Anonymous sign-in failed:", error);
                    document.getElementById('user-id-display').textContent = 'Auth failed';
                }
            }
        });

        // Start authentication
        signInAnonymously(auth).catch(error => {
            console.error("Initial sign-in failed:", error);
        });
    </script>
</head>
<body class="selection:bg-yellow-400 selection:text-black">

    <div class="flex flex-col md:flex-row max-w-7xl w-full justify-center">

        <!-- Game Board Container -->
        <div class="board-container pixel-border p-1">
            <div id="game-board">
                <!-- Blocks generated by JS -->
            </div>
        </div>

        <!-- Info Panel (Score, Next, Leaderboard) -->
        <div class="info-panel flex flex-col gap-6 w-full md:w-64">
            
            <div id="status-message" class="text-xl text-center text-yellow-400 min-h-[3rem] p-2">
                PRESS 'START'
            </div>

            <!-- Game Stats -->
            <div class="pixel-border p-4">
                <h2 class="text-lg mb-2 text-yellow-500">SCORE</h2>
                <div id="score-display" class="text-3xl">0</div>
                <div class="h-px bg-gray-500 my-3"></div>
                <h2 class="text-lg mb-2 text-yellow-500">LEVEL</h2>
                <div id="level-display" class="text-2xl">1</div>
            </div>

            <!-- Next Piece Display -->
            <div class="pixel-border p-4">
                <h2 class="text-lg mb-2 text-yellow-500">NEXT</h2>
                <div id="next-piece-display" class="w-20 h-20 mx-auto grid grid-cols-4 grid-rows-4 bg-[#0d0d1a] p-1 border-2 border-gray-700">
                    <!-- Blocks for next piece -->
                </div>
            </div>

            <!-- Leaderboard -->
            <div id="leaderboard-container" class="pixel-border p-4">
                <h2 class="text-lg mb-3 text-red-500">HIGH SCORES</h2>
                <ol id="leaderboard-list" class="text-sm space-y-1">
                    <p>Loading...</p>
                </ol>
                <div class="h-px bg-gray-500 my-3"></div>
                <div id="user-id-display" class="text-xs text-gray-400 break-all">Authenticating...</div>
            </div>

            <!-- Controls -->
            <button id="start-button" class="touch-button text-xl text-black bg-green-500 hover:bg-green-600 active:bg-green-700 w-full">
                START
            </button>
            <button id="pause-button" class="touch-button text-xl text-black bg-yellow-500 hover:bg-yellow-600 active:bg-yellow-700 w-full hidden">
                PAUSE
            </button>
        </div>
    </div>

    <!-- Mobile Touch Controls -->
    <div id="touch-controls" class="md:hidden flex flex-col w-full max-w-xs mx-auto gap-2">
        <div class="flex justify-center gap-2">
            <button data-action="rotate" class="touch-button w-20 h-16 text-2xl">‚Üª</button>
        </div>
        <div class="flex justify-between gap-2">
            <button data-action="left" class="touch-button w-20 h-16 text-2xl">‚Üê</button>
            <button data-action="down" class="touch-button flex-grow h-16 text-2xl">‚Üì</button>
            <button data-action="right" class="touch-button w-20 h-16 text-2xl">‚Üí</button>
        </div>
        <button data-action="hard-drop" class="touch-button w-full h-12 text-sm bg-blue-500 hover:bg-blue-600 active:bg-blue-700">HARD DROP</button>
    </div>

    <!-- Name Input Modal (hi·ªán sau khi Game Over) -->
    <div id="name-modal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-900 border-4 border-yellow-500 p-8 max-w-md w-full mx-4 pixel-border">
            <h2 class="text-2xl font-bold text-yellow-400 mb-4 text-center">üéÆ GAME OVER!</h2>
            <div class="text-center mb-6">
                <p class="text-white text-xl mb-2">Your Score:</p>
                <p id="modal-score" class="text-yellow-300 text-4xl font-bold">0</p>
            </div>
            
            <div id="name-input-section" class="mb-6">
                <label class="block text-yellow-400 text-sm font-bold mb-2">Enter Your Name:</label>
                <input 
                    id="player-name-input" 
                    type="text" 
                    maxlength="20" 
                    placeholder="Your name (max 20 chars)"
                    class="w-full p-3 bg-gray-800 border-2 border-gray-600 text-white text-lg focus:border-yellow-500 focus:outline-none"
                />
                <p class="text-gray-400 text-xs mt-2">* Ch·ªâ ƒë∆∞·ª£c ƒë·ªïi t√™n 1 l·∫ßn/ng√†y</p>
            </div>

            <div id="name-locked-section" class="mb-6 hidden">
                <p class="text-gray-400 text-sm mb-2">Playing as:</p>
                <p id="current-player-name" class="text-yellow-300 text-xl font-bold"></p>
                <p class="text-gray-500 text-xs mt-2">üîí B·∫°n ƒë√£ ƒë·∫∑t t√™n h√¥m nay. Quay l·∫°i v√†o ng√†y mai ƒë·ªÉ ƒë·ªïi t√™n.</p>
            </div>

            <div class="flex gap-3">
                <button id="save-score-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 text-lg">
                    üíæ SAVE SCORE
                </button>
                <button id="skip-save-btn" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 text-lg">
                    SKIP
                </button>
            </div>
            
            <p id="save-status" class="text-sm text-center mt-4 min-h-[20px]"></p>
        </div>
    </div>

    <script type="module">
        // --- HELPER FUNCTIONS FOR NAME MANAGEMENT ---
        
        /**
         * L·∫•y ng√†y hi·ªán t·∫°i d·∫°ng YYYY-MM-DD
         */
        function getTodayString() {
            const now = new Date();
            return now.toISOString().split('T')[0];
        }

        /**
         * Ki·ªÉm tra xem user ƒë√£ ƒë·∫∑t t√™n h√¥m nay ch∆∞a
         */
        function canChangeNameToday() {
            const lastNameChangeDate = localStorage.getItem('lastNameChangeDate');
            const today = getTodayString();
            return lastNameChangeDate !== today;
        }

        /**
         * L∆∞u t√™n ng∆∞·ªùi ch∆°i v√† ghi nh·∫≠n ng√†y ƒë·ªïi t√™n
         */
        function savePlayerName(name) {
            localStorage.setItem('playerName', name);
            localStorage.setItem('lastNameChangeDate', getTodayString());
        }

        /**
         * L·∫•y t√™n ng∆∞·ªùi ch∆°i hi·ªán t·∫°i
         */
        function getPlayerName() {
            return localStorage.getItem('playerName') || null;
        }

        // --- GAME CONSTANTS ---
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const NEXT_GRID_SIZE = 4;
        const SCORE_PER_LINE = 10;
        const LINES_PER_LEVEL = 10;
        const INITIAL_DROP_DELAY = 1000; // ms

        // Tetromino shapes and their colors (color index 1-7)
        const SHAPES = [
            // 0: T-shape
            [[0, 1, 0], [1, 1, 1], [0, 0, 0],], 
            // 1: I-shape
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0],], 
            // 2: J-shape
            [[1, 0, 0], [1, 1, 1], [0, 0, 0],], 
            // 3: L-shape
            [[0, 0, 1], [1, 1, 1], [0, 0, 0],], 
            // 4: O-shape
            [[1, 1], [1, 1],], 
            // 5: S-shape
            [[0, 1, 1], [1, 1, 0], [0, 0, 0],], 
            // 6: Z-shape
            [[1, 1, 0], [0, 1, 1], [0, 0, 0],], 
        ];

        // The index in COLORS corresponds to the color-N class in CSS
        const COLORS = [
            null, // Index 0 is reserved for empty space
            'color-1', // T: Pink
            'color-2', // I: Cyan
            'color-3', // J: Lime Green
            'color-4', // L: Orange
            'color-5', // O: Yellow
            'color-6', // S: Red
            'color-7', // Z: Blue Violet
        ];

        // --- GAME STATE ---
        let board = [];
        let currentPiece = null;
        let nextPiece = null;
        let score = 0;
        let lines = 0;
        let level = 1;
        let isPlaying = false;
        let isPaused = false;
        let dropIntervalId = null;

        // --- DOM ELEMENTS ---
        const boardEl = document.getElementById('game-board');
        const scoreEl = document.getElementById('score-display');
        const levelEl = document.getElementById('level-display');
        const nextPieceEl = document.getElementById('next-piece-display');
        const statusEl = document.getElementById('status-message');
        const startButton = document.getElementById('start-button');
        const pauseButton = document.getElementById('pause-button');
        const touchControls = document.getElementById('touch-controls');
        const leaderboardListEl = document.getElementById('leaderboard-list');
        
        // Modal elements
        const nameModal = document.getElementById('name-modal');
        const modalScore = document.getElementById('modal-score');
        const playerNameInput = document.getElementById('player-name-input');
        const nameInputSection = document.getElementById('name-input-section');
        const nameLockedSection = document.getElementById('name-locked-section');
        const currentPlayerNameEl = document.getElementById('current-player-name');
        const saveScoreBtn = document.getElementById('save-score-btn');
        const skipSaveBtn = document.getElementById('skip-save-btn');
        const saveStatus = document.getElementById('save-status');

        // --- FIREBASE/LEADERBOARD FUNCTIONS (REALTIME DATABASE) ---

        /**
         * Saves the current score to the Realtime Database leaderboard.
         * Only updates if the new score is higher than the existing one.
         */
        window.saveScore = async (finalScore) => {
            if (!window.db || !window.userId) {
                console.log("Cannot save score: Firebase or User ID not initialized.");
                saveStatus.textContent = '‚ùå Firebase not initialized';
                saveStatus.className = 'text-sm text-center mt-4 text-red-400';
                return false;
            }

            const { ref, set, get } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js");
            
            // Get player name from localStorage or use short ID
            const playerName = getPlayerName() || window.userId.substring(0, 8);
            const userRef = ref(window.db, `leaderboards/global/${window.userId}`);

            try {
                // Check existing score
                const snapshot = await get(userRef);
                const existingData = snapshot.val();

                // Only save if no existing score OR new score is higher
                if (!existingData || finalScore > existingData.score) {
                    await set(userRef, {
                        name: playerName,
                        score: finalScore,
                        updatedAt: Date.now()
                    });
                    console.log(`Score saved: ${finalScore} (Previous: ${existingData?.score || 0})`);
                    
                    saveStatus.textContent = existingData 
                        ? `üéâ New High Score! ${finalScore} (Previous: ${existingData.score})`
                        : `‚úÖ Score saved: ${finalScore}`;
                    saveStatus.className = 'text-sm text-center mt-4 text-green-400';
                    return true;
                } else {
                    console.log(`Score ${finalScore} not saved. Current best: ${existingData.score}`);
                    saveStatus.textContent = `‚ö†Ô∏è Your best score is still ${existingData.score}`;
                    saveStatus.className = 'text-sm text-center mt-4 text-yellow-400';
                    return false;
                }
            } catch (error) {
                console.error("Error saving score to Realtime Database:", error);
                saveStatus.textContent = `‚ùå Error: ${error.message}`;
                saveStatus.className = 'text-sm text-center mt-4 text-red-400';
                return false;
            }
        };

        /**
         * Loads and displays the leaderboard in real-time.
         * Shows top 10 scores, sorted by score descending.
         */
        window.loadLeaderboard = () => {
            if (!window.db) return;

            const { ref, query, orderByChild, limitToLast, onValue } = 
                window.loadLeaderboard.imports || {};
            
            // Import the functions if not already cached
            if (!window.loadLeaderboard.imports) {
                import("https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js")
                    .then(module => {
                        window.loadLeaderboard.imports = module;
                        window.loadLeaderboard(); // Retry after imports
                    });
                return;
            }

            const leaderboardRef = ref(window.db, 'leaderboards/global');
            const topScoresQuery = query(leaderboardRef, orderByChild('score'), limitToLast(10));

            // Listen to real-time updates
            onValue(topScoresQuery, (snapshot) => {
                const scores = [];
                snapshot.forEach((childSnapshot) => {
                    const data = childSnapshot.val();
                    scores.push({
                        uid: childSnapshot.key,
                        name: data.name,
                        score: data.score,
                        updatedAt: data.updatedAt
                    });
                });

                // Sort descending (limitToLast gives ascending order)
                scores.sort((a, b) => b.score - a.score);

                // Display leaderboard
                leaderboardListEl.innerHTML = '';
                if (scores.length === 0) {
                    leaderboardListEl.innerHTML = '<p class="text-gray-400">No scores yet! Be the first!</p>';
                    return;
                }

                scores.forEach((entry, index) => {
                    const isCurrentUser = entry.uid === window.userId;
                    const listItem = document.createElement('li');
                    listItem.className = `flex justify-between ${isCurrentUser ? 'text-yellow-300 font-bold' : 'text-white'}`;
                    listItem.innerHTML = `
                        <span class="w-1/12">${index + 1}.</span>
                        <span class="w-7/12 truncate">${entry.name}</span>
                        <span class="w-4/12 text-right">${entry.score}</span>
                    `;
                    leaderboardListEl.appendChild(listItem);
                });
            }, (error) => {
                console.error("Error listening to leaderboard:", error);
                leaderboardListEl.innerHTML = '<p class="text-red-400 text-sm">Error loading leaderboard.</p>';
            });
        };

        // --- GAME LOGIC FUNCTIONS ---

        /**
         * Creates an empty game board (20 rows x 10 columns).
         */
        function createBoard() {
            board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0));
        }

        /**
         * Generates a random tetromino piece.
         * @returns {object} The new piece object.
         */
        function getRandomPiece() {
            const index = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[index];
            const color = index + 1; // Color index starts at 1
            const startX = Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2);

            return {
                shape: shape,
                color: color,
                x: startX,
                y: 0,
            };
        }

        /**
         * Draws the game board state onto the DOM.
         */
        function drawBoard() {
            boardEl.innerHTML = '';
            board.forEach((row, r) => {
                row.forEach((cell, c) => {
                    const block = document.createElement('div');
                    block.classList.add('block');
                    if (cell !== 0) {
                        block.classList.add(COLORS[cell]);
                    }
                    // Hide the top two rows from being fully visible
                    if (r < 2) {
                        block.style.visibility = 'hidden';
                    }
                    boardEl.appendChild(block);
                });
            });

            if (currentPiece) {
                drawPiece(currentPiece);
            }
        }

        /**
         * Draws a single piece onto the board in its current position.
         * @param {object} piece - The piece to draw.
         */
        function drawPiece(piece) {
            piece.shape.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if (cell) {
                        const boardX = piece.x + c;
                        const boardY = piece.y + r;

                        if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                            const index = boardY * BOARD_WIDTH + boardX;
                            const block = boardEl.children[index];
                            if (block) {
                                block.classList.remove(...COLORS);
                                block.classList.add(COLORS[piece.color], 'current-piece-cell');
                                block.style.visibility = 'visible'; // Ensure current piece is visible even in ghost rows
                            }
                        }
                    }
                });
            });
        }

        /**
         * Draws the next piece in the side panel.
         */
        function drawNextPiece() {
            nextPieceEl.innerHTML = '';
            // Fill the next piece grid with empty blocks
            for (let i = 0; i < NEXT_GRID_SIZE * NEXT_GRID_SIZE; i++) {
                const block = document.createElement('div');
                block.classList.add('block', 'w-1/4', 'h-1/4', 'border-gray-800');
                nextPieceEl.appendChild(block);
            }

            if (nextPiece) {
                const startRow = Math.floor((NEXT_GRID_SIZE - nextPiece.shape.length) / 2);
                const startCol = Math.floor((NEXT_GRID_SIZE - nextPiece.shape[0].length) / 2);

                nextPiece.shape.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            const gridX = startCol + c;
                            const gridY = startRow + r;
                            const index = gridY * NEXT_GRID_SIZE + gridX;
                            
                            const block = nextPieceEl.children[index];
                            if (block) {
                                block.classList.add(COLORS[nextPiece.color]);
                            }
                        }
                    });
                });
            }
        }

        /**
         * Checks if the piece at the given position collides with boundaries or existing blocks.
         * @param {object} piece - The piece to check.
         * @returns {boolean} True if collision occurs, false otherwise.
         */
        function checkCollision(piece) {
            for (let r = 0; r < piece.shape.length; r++) {
                for (let c = 0; c < piece.shape[r].length; c++) {
                    if (piece.shape[r][c]) {
                        const boardX = piece.x + c;
                        const boardY = piece.y + r;

                        // Check boundaries
                        if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT) {
                            return true;
                        }
                        
                        // Check for collision with existing blocks on the board (ignore top "ghost" rows)
                        if (boardY >= 0 && boardY < BOARD_HEIGHT && board[boardY][boardX] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /**
         * Locks the current piece into the board state.
         */
        function lockPiece() {
            currentPiece.shape.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if (cell) {
                        const boardX = currentPiece.x + c;
                        const boardY = currentPiece.y + r;
                        // Only lock blocks that are within the visible board area (Y >= 0)
                        if (boardY >= 0) {
                            board[boardY][boardX] = currentPiece.color;
                        }
                    }
                });
            });
        }

        /**
         * Clears full lines and updates score/level.
         */
        function clearLines() {
            let linesCleared = 0;
            for (let r = BOARD_HEIGHT - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    // Line is full, clear it
                    linesCleared++;
                    // Move all rows above down by one
                    for (let rr = r; rr > 0; rr--) {
                        board[rr] = board[rr - 1];
                    }
                    // Top row is now empty
                    board[0] = Array(BOARD_WIDTH).fill(0);
                    // Rerun the check for the same row since content has shifted
                    r++; 
                }
            }

            if (linesCleared > 0) {
                const scoreMultiplier = [0, 1, 3, 5, 8]; // Score for 0, 1, 2, 3, 4 lines (TETRIS!)
                score += scoreMultiplier[linesCleared] * SCORE_PER_LINE * level;
                lines += linesCleared;
                
                // Check for level up
                const newLevel = Math.floor(lines / LINES_PER_LEVEL) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    restartDropInterval();
                }

                updateStats();
            }
        }

        /**
         * Moves the current piece in a given direction.
         * @param {number} dx - Change in X (column).
         * @param {number} dy - Change in Y (row).
         */
        function movePiece(dx, dy) {
            if (!currentPiece) return;
            const newPiece = { ...currentPiece, x: currentPiece.x + dx, y: currentPiece.y + dy };

            if (!checkCollision(newPiece)) {
                currentPiece = newPiece;
                drawBoard();
                return true;
            }
            return false;
        }

        /**
         * Hard drops the current piece to the bottom.
         */
        function hardDrop() {
            if (!currentPiece) return;
            let drops = 0;
            while (movePiece(0, 1)) {
                drops++;
            }
            // Lock the piece immediately after hard drop
            if (drops > 0) {
                gameTick(true);
            }
        }

        /**
         * Rotates the current piece 90 degrees clockwise.
         */
        function rotatePiece() {
            if (!currentPiece) return;
            const shape = currentPiece.shape;
            const size = shape.length;
            const newShape = Array.from({ length: size }, () => Array(size).fill(0));

            // Perform rotation (transpose and reverse rows)
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    newShape[c][size - 1 - r] = shape[r][c];
                }
            }

            const newPiece = { ...currentPiece, shape: newShape };

            // Kick-testing: Try to move the piece slightly if the rotation causes a collision
            const kicks = [[0, 0], [-1, 0], [1, 0], [0, -1], [0, 1]];
            for (const [kx, ky] of kicks) {
                const kickedPiece = { ...newPiece, x: newPiece.x + kx, y: newPiece.y + ky };
                if (!checkCollision(kickedPiece)) {
                    currentPiece = kickedPiece;
                    drawBoard();
                    return;
                }
            }
        }

        /**
         * The main game loop tick (gravity).
         * @param {boolean} forceLock - Whether to force a lock if movement fails (used for hard drop).
         */
        function gameTick(forceLock = false) {
            if (!isPlaying || isPaused) return;

            // 1. Try to move down
            const moved = movePiece(0, 1);

            // 2. If movement failed (collision), lock the piece
            if (!moved || forceLock) {
                lockPiece();
                clearLines();

                // 3. Spawn next piece
                currentPiece = nextPiece;
                nextPiece = getRandomPiece();
                drawNextPiece();

                // 4. Check for Game Over (new piece immediately collides)
                if (checkCollision(currentPiece)) {
                    endGame();
                    return;
                }
                drawBoard(); // Draw the newly spawned piece
            }
        }

        /**
         * Updates score and level displays.
         */
        function updateStats() {
            scoreEl.textContent = score;
            levelEl.textContent = level;
        }

        /**
         * Starts the piece dropping interval.
         */
        function startDropInterval() {
            const dropDelay = INITIAL_DROP_DELAY / level;
            if (dropIntervalId) clearInterval(dropIntervalId);
            dropIntervalId = setInterval(gameTick, dropDelay);
        }

        /**
         * Restarts the drop interval after a level change.
         */
        function restartDropInterval() {
            if (isPlaying && !isPaused) {
                startDropInterval();
            }
        }

        // --- GAME CONTROL ---

        /**
         * Initializes and starts a new game.
         */
        function startGame() {
            if (isPlaying) return;

            // Reset state
            createBoard();
            score = 0;
            lines = 0;
            level = 1;
            updateStats();

            // Setup initial pieces
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece();
            drawNextPiece();

            isPlaying = true;
            isPaused = false;
            statusEl.textContent = 'GAME ON!';
            startButton.classList.add('hidden');
            pauseButton.classList.remove('hidden');

            drawBoard();
            startDropInterval();
            attachInputHandlers();
        }

        /**
         * Pauses the game.
         */
        function pauseGame() {
            if (!isPlaying) return;

            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(dropIntervalId);
                dropIntervalId = null;
                statusEl.textContent = 'PAUSED';
                pauseButton.textContent = 'RESUME';
            } else {
                startDropInterval();
                statusEl.textContent = 'GAME ON!';
                pauseButton.textContent = 'PAUSE';
            }
        }

        /**
         * Ends the game.
         */
        function endGame() {
            isPlaying = false;
            if (dropIntervalId) clearInterval(dropIntervalId);
            dropIntervalId = null;
            
            statusEl.textContent = `GAME OVER! Score: ${score}`;
            startButton.textContent = 'RESTART';
            startButton.classList.remove('hidden');
            pauseButton.classList.add('hidden');

            // Flash the board (optional)
            boardEl.style.opacity = '0.5';
            setTimeout(() => { boardEl.style.opacity = '1'; }, 100);
            
            // Show name input modal instead of auto-saving
            showNameModal(score);

            // Remove input handlers until restart
            document.removeEventListener('keydown', handleKeyDown);
            touchControls.removeEventListener('click', handleTouchControls);
        }

        /**
         * Shows the name input modal after game over
         */
        function showNameModal(finalScore) {
            modalScore.textContent = finalScore;
            saveStatus.textContent = '';
            
            const currentName = getPlayerName();
            const canChangeName = canChangeNameToday();

            if (canChangeName) {
                // Cho ph√©p nh·∫≠p t√™n
                nameInputSection.classList.remove('hidden');
                nameLockedSection.classList.add('hidden');
                playerNameInput.value = currentName || '';
                playerNameInput.disabled = false;
            } else {
                // ƒê√£ ƒë·∫∑t t√™n h√¥m nay, ch·ªâ hi·ªÉn th·ªã
                nameInputSection.classList.add('hidden');
                nameLockedSection.classList.remove('hidden');
                currentPlayerNameEl.textContent = currentName || 'Anonymous';
            }

            // Show modal
            nameModal.classList.remove('hidden');
        }

        /**
         * Hides the name modal
         */
        function hideNameModal() {
            nameModal.classList.add('hidden');
        }

        // --- INPUT HANDLING ---

        function handleKeyDown(event) {
            if (!isPlaying || isPaused) {
                if (event.key === ' ' && !isPlaying) {
                    startGame();
                } else if (event.key === 'p' || event.key === 'P') {
                    pauseGame();
                }
                return;
            }

            switch (event.key) {
                case 'ArrowLeft':
                    movePiece(-1, 0);
                    break;
                case 'ArrowRight':
                    movePiece(1, 0);
                    break;
                case 'ArrowDown':
                    // Soft drop
                    movePiece(0, 1);
                    break;
                case 'ArrowUp':
                case 'x':
                    rotatePiece();
                    break;
                case ' ': // Hard drop
                    hardDrop();
                    // Prevent the spacebar from scrolling the page
                    event.preventDefault(); 
                    break;
                case 'p':
                case 'P':
                    pauseGame();
                    break;
            }
        }

        function handleTouchControls(event) {
            const action = event.target.closest('button')?.dataset.action;
            if (!action || !isPlaying || isPaused) return;

            switch (action) {
                case 'left':
                    movePiece(-1, 0);
                    break;
                case 'right':
                    movePiece(1, 0);
                    break;
                case 'down':
                    movePiece(0, 1);
                    break;
                case 'rotate':
                    rotatePiece();
                    break;
                case 'hard-drop':
                    hardDrop();
                    break;
            }
        }

        function attachInputHandlers() {
            document.addEventListener('keydown', handleKeyDown);
            touchControls.addEventListener('click', handleTouchControls);
        }

        // --- INITIALIZATION ---
        
        startButton.addEventListener('click', startGame);
        pauseButton.addEventListener('click', pauseGame);
        
        // Modal button handlers
        saveScoreBtn.addEventListener('click', async () => {
            // L∆∞u t√™n n·∫øu c√≥ th·ªÉ thay ƒë·ªïi
            if (canChangeNameToday()) {
                const newName = playerNameInput.value.trim();
                if (newName && newName.length > 0 && newName.length <= 20) {
                    savePlayerName(newName);
                    console.log(`Player name saved: ${newName}`);
                    
                    // Update user display
                    const displayName = newName;
                    document.getElementById('user-id-display').textContent = `Player: ${displayName}`;
                } else if (newName.length > 20) {
                    saveStatus.textContent = '‚ùå Name too long (max 20 characters)';
                    saveStatus.className = 'text-sm text-center mt-4 text-red-400';
                    return;
                }
            }

            // Disable button while saving
            saveScoreBtn.disabled = true;
            saveStatus.textContent = '‚è≥ Saving...';
            saveStatus.className = 'text-sm text-center mt-4 text-yellow-400';

            // Save score
            const finalScore = parseInt(modalScore.textContent);
            const saved = await window.saveScore(finalScore);

            // Re-enable button
            saveScoreBtn.disabled = false;

            // Close modal after 2 seconds if successful
            if (saved) {
                setTimeout(() => {
                    hideNameModal();
                }, 2000);
            }
        });

        skipSaveBtn.addEventListener('click', () => {
            hideNameModal();
        });

        // Close modal when clicking outside
        nameModal.addEventListener('click', (e) => {
            if (e.target === nameModal) {
                hideNameModal();
            }
        });
        
        // Initial setup for the board display (empty)
        createBoard();
        drawBoard(); 
        drawNextPiece();
        updateStats();

        // Attach initial keydown listener for Start/Pause functionality
        document.addEventListener('keydown', handleKeyDown);
        
        // The loadLeaderboard function will be called automatically once Firebase auth is ready.

    </script>

</body>
</html>
